<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Freeray </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.1/xlsx.full.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
</head>
<body>
    <div class="container-fluid">

        <div></div>

    <br><br>

    <img style="width: 250px; margin: auto; display: block;" src="./images/400dpiLogoCropped (1).jpg"/>


    <div id="loadingIndicator" style=" display:none; text-align:center;">
        <p>Loading...</p>
        <img src="https://i.gifer.com/ZZ5H.gif" alt="Loading" width="50" />

    </div>

<div class="d-flex m-5">
     
        <div class="w-100 m-5"><input 
            type="text"
            id="searchBar"
            placeholder="Search for a name..."
            style=" padding: 5px; font-size: 16px;"
        />
        </div>
    

    <button id="save" class="btn btn-primary p-3 m-5">Save Roster Updated File</button>

    <div class="m-5"><label class="text-center">Date of Report: </label> <input type="date" id="datePicker"/></div>

    </div>
<div style="color: red; width: 450px; margin: auto;">
    <p><b>Please note before submitting files:</b></p>
    <ul>
        <li>Date of Service</li>
        <li>Patient  Name = Name</li>
        <li>First row not be empty</li>
        <li>Only one insurance header</li>
    </ul>
    </div>

    <div class="d-flex justify-content-around">
        <i><h1>Billed File:</h1></i>

        <i><h1>Roster File:</h1></i>
    </div>


    <div class="m-5" style="display: inline-block; width: 45%; vertical-align: top;  max-height: 85vh; overflow-y: auto; border: 1px solid #020202; overflow-x: scroll;">
       
        <input type="file" id="upload"/>

        <table id="excelData" style="min-width: 120%;"></table>

    </div>

    
    <div class="m-5" style="display: inline-block; width: 40%; vertical-align: top; vertical-align: top;  max-height: 85vh; overflow-y: auto; border: 1px solid #020202; overflow-x: scroll;">
        
        <input type="file" id="upload2"/>
        <table id="excelData2" style="min-width: 120%;"></table>
        </div>

    </div>

    


    <script>

        let table1Data = [];
        let table2Data = [];


        const searchBar = document.getElementById('searchBar');

        searchBar.addEventListener('keydown', function(event){
            if (event.key === 'Enter'){
                const query = this.value.toLowerCase().trim();
                filterTables(query)
            }
        });

        searchBar.addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();
            if(!query) {
                renderTable('excelData', table1Data);
                renderTable('excelData2', table2Data)
            }
        });


        async function filterTables(query) {
            if(!query) return;


            const filterRow = async (row) =>{
                return Object.values(row).some(
                    (value) => 

                    value && 
                    value.toString().toLowerCase().includes(query)
                )
            };

            const filteredTable1 = await Promise.all(
                table1Data.map(async (row) => (await filterRow(row) ? row : null))
            );

            const filteredTable2 = await Promise.all(
                table2Data.map(async (row) => (await filterRow(row) ? row : null))
            );

            const cleanTable1 = filteredTable1.filter((row) => row !== null);
            const cleanTable2 = filteredTable2.filter((row) => row !== null);

            renderTable('excelData', cleanTable1);
            renderTable('excelData2', cleanTable2)
            
        };

        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(event.target.result);
                reader.onerror =  error => reject(error);
                reader.readAsBinaryString(file)
                
            })
        };

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms))
        }

        // below checks if table1data and table2data name and date_of_service match if it 
        // does the Paid column from table1data is going into table2 data table 

        async function updatePaidAmountsAsync() {
        document.getElementById('loadingIndicator').style.display = 'block';

    let updatedCount = 0;
    const unmatchedRows = [];
    let unmatchedRowsAdded = false
    const totalRows = table2Data.length;
    const seenNameAndDates = new Set();

    const insuranceHeader = Object.keys(table1Data[0] || {}).find(header =>
        header.toLowerCase().includes('insurance')
    );

    if (!insuranceHeader) {
        console.error('No Insurance-related column found in table1Data.');
        document.getElementById('loadingIndicator').style.display = 'none';
        return;
    }

  

    for (let i = 0; i < table2Data.length; i++) {
        const row2 = table2Data[i];
        let matchFound = false;
        const nameAndDateKey = `${row2.Name?.toLowerCase().trim()}-${row2['Date of Service']}`;

        seenNameAndDates.add(nameAndDateKey);

        for (const row1 of table1Data) {
            if (
                row1.Name?.toLowerCase().trim() === row2.Name?.toLowerCase().trim() &&
                row1['Date of Service'] === row2['Date of Service']
            ) {
                row2.Paid = row1.Paid;
                row2['Billed Insurance'] = row1[insuranceHeader] || 'Not Found';
                matchFound = true;
                updatedCount++;
                break;
            }
        }

        if (!matchFound) {
            row2.Paid = 'Not Found in Billing File';
            row2['Billed Insurance'] = 'Not Specified';
            
            }
        

        if (i % 500 === 0) {
            // Periodically render table to avoid freezing the UI
            renderTable('excelData2', table2Data);
            await sleep(1000); // Pause to prevent browser from freezing
            document.getElementById('loadingIndicator').style.display = 'block';
        }
    }

    for (const row1 of table1Data){
        const nameAndDateKey = `${row1.Name?.toLowerCase().trim()}-${row1['Date of Service']}`;

    if(!seenNameAndDates.has(nameAndDateKey)){
        const newRow ={
        Name : row1.Name,
        'Date of Service': row1['Date of Service'],
        Paid: row1.Paid,
        'Billed Insurance': row1[insuranceHeader] || 'Not Found', 
        };

        unmatchedRows.push(newRow)
    }
}

if (unmatchedRows.length > 0) {
        for (const unmatchedRow of unmatchedRows) {
            table2Data.push(unmatchedRow); // Add the unmatched rows to the end of table2Data
        }
        renderTable('excelData2', table2Data); // Re-render the table with the new data

        // Optionally, apply red text color via inline style or CSS class
        const tableRows = document.querySelectorAll('#excelData2 tr');
        tableRows.forEach(row => {
            if (row.contains(document.createTextNode('Not Found In Billing Table'))) {
                row.style.color = 'red'; // Apply red text color
            }
        });
    

    
    
    document.getElementById('loadingIndicator').style.display = 'none';
    renderTable('excelData2', table2Data);
    console.log(`Update Complete. ${updatedCount} rows updated.`);
    console.log(`Rows in Table2data that did not match the name and Date of Service in table1data (${unmatchedRows.length}):`, unmatchedRows);

}
}
       
        
       
    function excelDateToJSDate (serial) {
        if(!serial || typeof serial !== 'number'){
            return '';
        }
        const epoch = new Date(1899, 11, 30);
        const jsDate = new Date(epoch.getTime() + (serial * 86400000));

        const day = jsDate.getDate().toString().padStart(2, '0');
        const month = (jsDate.getMonth() + 1).toString().padStart(2,'0');

        const year = jsDate.getFullYear();

        return `${month}/${day}/${year}`;

    }

    function isSerialDate(value){
        return typeof value === 'number' && value > 0 && value < 60000;
    }


    function renderTable(tableId, data){
        const tableElement = document.getElementById(tableId);
        const loadingIndicator = document.getElementById('loadingIndicator');

        if(!tableElement){
            console.error(`Element with ID ${tableId} not Found!.`);
            return;
        }


        

        if(!data || data.length === 0){
            tableElement.innerHTML = 'No Data Available';
            if(loadingIndicator){
                loadingIndicator.style.display = 'none';
            }
            return;
        }

        let tableHTML = '<thead><tr>';
        const headers = Object.keys(data[0]);
        headers.forEach(header =>{
            tableHTML += `<th>${header}</th>`;
        });
        tableHTML += '<tr></thead><tbody class="table table-bordered">';

        data.forEach(row => {
            tableHTML += '<tr>';
            headers.forEach(header => {
                let cellValue = row[header];
                if (header.toLocaleLowerCase().includes('date') && isSerialDate(cellValue)){
                    cellValue = excelDateToJSDate(cellValue)
                }
                
                tableHTML += `<td>${cellValue != null ? cellValue : ''}</td>`;
                
            });
            tableHTML += '</tr>';
        });

        tableHTML += '</tbody>';
        tableElement.innerHTML = tableHTML;

       
    }



        document.getElementById('upload').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const reader = new FileReader();

            
    reader.onload = function (event) {
        const data = event.target.result;
        const workbook = XLSX.read(data, { type: 'binary' }); 
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];

        let rawData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        let firstRow = rawData[0] || [];
        let secondRow = rawData[1] || [];

        const isFirstRowEmty = firstRow.every(cell => cell === '' || cell == null);

        let headers = isFirstRowEmty ? secondRow : firstRow;

        headers = headers.map(header => header.trim())

        let dataRows = rawData.slice(isFirstRowEmty ? 2 : 1);

        table1Data = dataRows.map(row => {
            let rowData = {};
            headers.forEach((header , index ) => {
                rowData[header] = row[index];
            });
            return rowData;
        });

        renderTable('excelData', table1Data)
    };
            

            reader.readAsBinaryString(file);
        });


        let selectedDate = ''; // Global variable to store the selected date

document.getElementById('datePicker').addEventListener('change', function (e) {
    selectedDate = e.target.value; // Store the selected date
    if (selectedDate) {
        // If the date is selected, apply it to table2Data if it's already loaded
        const [year,month, day] = selectedDate.split('-');
        const formattedDate = `${month}/${day}/${year}`;
        table2Data.forEach(row => {
            row["Date of Report"] = formattedDate; // Update the "Date of Billed" for each row
        });
        renderTable('excelData2', table2Data); // Re-render table 2 with new "Date of Billed"
    }
});

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

document.getElementById('upload2').addEventListener('change', function(e){
    const file = e.target.files[0];
    const reader = new FileReader();

    


    reader.onload = function (event) {
        const data = event.target.result;
        const workbook = XLSX.read(data, { type: 'binary' } );
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName]

        let rawData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        let firstRow = rawData[0] || [];
        let secondRow = rawData[1] || [];

        const isFirstRowEmty = firstRow.every(cell => cell === '' || cell == null);

        let headers = isFirstRowEmty ? secondRow : firstRow;

        headers = headers.map(header => (header ? header.trim() : ''));

        let dataRows = rawData.slice(isFirstRowEmty ? 2 : 1);

        table2Data = dataRows.map(row => {
            let rowData = {};
            headers.forEach((header, index) => {
                rowData[header] = row[index];
            });

            return rowData;
        })


       if(table2Data.length > 0){
        const headers = Object.keys(table2Data[0]);
        headers.forEach(header => {
            const trimmedHeaders = header.trim();
            if(trimmedHeaders !== header){
                table2Data.forEach(row => {
                    row[trimmedHeaders] = row[header]
                    
                    delete row[header]
                })
            }
        })
       }


        if (selectedDate) {
            table2Data.forEach(row => {
                row["Date of Billed"] = selectedDate;
            });
        }

        renderTable('excelData2', table2Data);

        updatePaidAmountsAsync();

        document.getElementById('loadingIndicator').style.display = 'none';
    };

    reader.readAsBinaryString(file)
});
   


        document.getElementById('save').addEventListener('click', function () {
            if(!selectedDate){
                alert('Please Pick A Date of Report To Proceed');
                return;
            }

            if (table2Data.length === 0) {
                alert("No data available to save.");
                return;
            }

            const worksheet = XLSX.utils.json_to_sheet(table2Data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Updated Data');
            XLSX.writeFile(workbook, `${selectedDate} Updated_File.xlsx`);
        });


    



    </script>
</body>
</html>



