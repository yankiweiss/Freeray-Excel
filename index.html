<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.1/xlsx.full.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
</head>

<body>

    <br><br>

    <img style="width: 250px; margin: auto; display: block;" src="./images/Screenshot 2024-12-05 155457.png">


    <div id="loadingIndicator" style="display:none; text-align:center;">
        <p>Loading...</p>
        <img src="https://i.gifer.com/ZZ5H.gif" alt="Loading" width="50" />

    </div>


    <div style="margin: 20px 0;">
        <input
            type="text"
            id="searchBar"
            placeholder="Search for a name..."
            style="width: 300px; padding: 5px; font-size: 16px;"
        />
    </div>

   

    <div style="display: inline-block; width: 70%; vertical-align: top;">
        <!-- File input and table 1 -->
        <p>Upload Billed File:</p>

        <br><br>
        
        <input type="file" id="upload" />
        <table id="excelData" style="width: 100%;"></table>
    </div>

    <div style="display: inline-block; width: 20%; vertical-align: top;">
        <!-- File input and table 2 -->
        <p>Upload Roaster File:</p>

        <label>Billing Date:</label> <input type="date" id="datePicker">

        <br><br>
        <input type="file" id="upload2" />
        <table id="excelData2" style="width: 100%;"></table>
    </div>

    
    

   



    <button id="save" class="btn btn-primary">Save Updated File</button>

    <script>
        let table1Data = [];
        let table2Data = [];


        document.getElementById('searchBar').addEventListener('input', function () {
    const query = this.value.toLowerCase().trim();
    filterTables(query);
});

function filterTables(query) {
    const filterRow = (row) => {
        return Object.values(row).some(
            (value) =>
                value &&
                value.toString().toLowerCase().includes(query)
        );
    };

    // Filter data from both tables
    const filteredTable1 = query ? table1Data.filter(filterRow) : table1Data;
    const filteredTable2 = query ? table2Data.filter(filterRow) : table2Data;

    // Re-render the tables with the filtered data
    renderTable('excelData', filteredTable1);
    renderTable('excelData2', filteredTable2);
}


        // below updates the Paid column on the second table with the paid amount from the first talbe 
        function updatePaidAmounts() {
    // Check for rows in table2Data that match rows in table1Data
    table2Data.forEach(row2 => {
        let matchFound = false;
        table1Data.forEach(row1 => {
            if (row1.Name?.toLowerCase().trim() === row2.Name?.toLowerCase().trim()
                && row1["Date of Service"] === row2["Date of Service"]) {
                row2.Paid = row1.Paid; // Update the Paid column in table2Data
                row2["Not Found in Roaster"] = ''; // Clear the "Not Found" message if matched
                matchFound = true;
            }
        });
        if (!matchFound) {
            row2.Paid = "Not Found";
            row2["Remarks"] = 'Not in Table1'; // Optional: Add remarks for rows not found in table1Data
        }
    });

    // Now check for rows in table1Data that do not exist in table2Data
    table1Data.forEach(row1 => {
        let matchFound = false;
        table2Data.forEach(row2 => {
            if (row1.Name?.toLowerCase().trim() === row2.Name?.toLowerCase().trim()
                && row1["Date of Service"] === row2["Date of Service"]) {
                matchFound = true;
            }
        });
        // If no match is found, add the row from table1Data to table2Data
        if (!matchFound) {
            // Add the row from table1Data to table2Data
            let newRow = { ...row1 }; // Clone the row to avoid modifying the original data
            newRow["Not Found in Roaster"] = 'Not Found in Roaster'; // Add the Not Found message
            newRow["Remarks"] = 'Not in Roaster'; // Add an additional Remarks/Status column
            table2Data.push(newRow); // Add the row to table2Data
        }
    });

    // Re-render table2Data with the updated rows
    renderTable('excelData2', table2Data);
}






        // below function is formating dates that comes in from Excel Seriel Format to dd/mm/yyyy format
        function excelDateToJSDate(serial) {
            if (!serial || typeof serial !== 'number') {
                // Return an empty string for empty or invalid input
                return '';
            }
            const epoch = new Date(1899, 11, 30); // Excel epoch date
            const jsDate = new Date(epoch.getTime() + (serial * 86400000));

            // Format the date to MM/DD/YYYY
            const day = jsDate.getDate().toString().padStart(2, '0');
            const month = (jsDate.getMonth() + 1).toString().padStart(2, '0');
            const year = jsDate.getFullYear();
            return `${month}/${day}/${year}`;
        }

        // Utility function to check if the value is a serial number (date)
        function isSerialDate(value) {
            return typeof value === 'number' && value > 0 && value < 60000;
        }

        // Example usage:
        const serialNumber = 45101; // Corresponds to 01/11/2024
        if (isSerialDate(serialNumber)) {
            const formattedDate = excelDateToJSDate(serialNumber);
            console.log(formattedDate); // Outputs: 01/11/2024
        }

        // Test with an empty value
        const emptyValue = null;
        const result = excelDateToJSDate(emptyValue);
        console.log(result); // Outputs: ''


        // Function to format dollar amounts
        function formatDollarAmount(value) {
            if (typeof value === 'number') {
                return `$${value.toFixed(2)}`;
            }
            return value;
        }


        function excelDateToJSDate(serial) {
    if (!serial || typeof serial !== 'number') {
        // Return an empty string for empty or invalid input
        return '';
    }
    const epoch = new Date(1899, 11, 30); // Excel epoch date
    const jsDate = new Date(epoch.getTime() + (serial * 86400000));
    
    // Format the date to MM/DD/YYYY
    const day = jsDate.getDate().toString().padStart(2, '0');
    const month = (jsDate.getMonth() + 1).toString().padStart(2, '0');
    const year = jsDate.getFullYear();
    return `${month}/${day}/${year}`;
}

// renderTable Function


/*function renderTable(tableId, data) {
    if (!data || data.length === 0) {
        document.getElementById(tableId).innerHTML = 'No data available.';
        return;
    }

    let tableHTML = '<thead><tr>';

    // Get the headers from the first row
    const headers = Object.keys(data[0]);

    // Render headers
    headers.forEach(header => {
        tableHTML += `<th scope="col">${header}</th>`;
    });

    tableHTML += '</tr></thead><tbody class="table table-bordered">';

    data.forEach(row => {
        tableHTML += '<tr>';
        headers.forEach(header => {
            let cellValue = row[header];

            // If the column header contains 'Date', treat it as a date
            if (header.toLowerCase().includes('date') && isSerialDate(cellValue)) {
                cellValue = excelDateToJSDate(cellValue);
            }
            // If the column header contains 'Amount' or similar, treat it as a dollar amount
            else if (header.toLowerCase().includes('amount') && typeof cellValue === 'number') {
                cellValue = formatDollarAmount(cellValue);
            }

            // Ensure empty or undefined values are displayed as empty cells
            tableHTML += `<td>${cellValue != null ? cellValue : ''}</td>`;
        });
        tableHTML += '</tr>';
    });

    tableHTML += '</tbody>';

    document.getElementById(tableId).innerHTML = tableHTML;
}*/


function renderTable(tableId, data) {
    if (!data || data.length === 0) {
        document.getElementById(tableId).innerHTML = 'No data available.';
        return;
    }

    const query = document.getElementById('searchBar').value.toLowerCase().trim();

    let tableHTML = '<thead><tr>';

    const headers = Object.keys(data[0]);
    headers.forEach(header => {
        tableHTML += `<th scope="col">${header}</th>`;
    });

    tableHTML += '</tr></thead><tbody class="table table-bordered">';

    data.forEach(row => {
        tableHTML += '<tr>';
        headers.forEach(header => {
            let cellValue = row[header];
            if (header.toLowerCase().includes('date') && isSerialDate(cellValue)) {
                cellValue = excelDateToJSDate(cellValue);
            } else if (header.toLowerCase().includes('amount') && typeof cellValue === 'number') {
                cellValue = formatDollarAmount(cellValue);
            }

            if (cellValue != null && query) {
                const regex = new RegExp(`(${query})`, 'gi');
                cellValue = cellValue.toString().replace(regex, '<mark>$1</mark>');
            }

            tableHTML += `<td>${cellValue != null ? cellValue : ''}</td>`;
        });
        tableHTML += '</tr>';
    });

    tableHTML += '</tbody>';
    document.getElementById(tableId).innerHTML = tableHTML;
}

        // Upload file 1
        document.getElementById('upload').addEventListener('change', function (e) {
            const file = e.target.files[0];
            const reader = new FileReader();

            reader.onload = function (event) {
                const data = event.target.result;
                const workbook = XLSX.read(data, { type: 'binary' });
                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];

                // Convert sheet to JSON data as raw rows
                let rawData = XLSX.utils.sheet_to_json(sheet, { header: 1 }); // Get raw data as an array of rows

                let firstRow = rawData[0];
                let secondRow = rawData[1];

                // Check if the first row only contains empty cells or commas
                const isFirstRowEmptyOrCommas = firstRow.every(cell => cell === '' || typeof cell === 'string' && cell.includes(','));

                // If the first row contains only commas or is empty, use the second row as keys
                if (isFirstRowEmptyOrCommas) {
                    // Use second row as keys
                    table1Data = rawData.slice(1).map(row => {
                        let rowData = {};
                        secondRow.forEach((key, index) => {
                            rowData[key] = row[index];
                        });
                        return rowData;
                    });
                } else {
                    // If the first row has valid keys, use it
                    table1Data = rawData.slice(1).map(row => {
                        let rowData = {};
                        firstRow.forEach((key, index) => {
                            rowData[key] = row[index];
                        });
                        return rowData;
                    });
                }

                renderTable('excelData', table1Data); // Render table 1 with the data
            };

            reader.readAsBinaryString(file);
        });


        let selectedDate = ''; // Global variable to store the selected date

document.getElementById('datePicker').addEventListener('change', function (e) {
    selectedDate = e.target.value; // Store the selected date
    if (selectedDate) {
        // If the date is selected, apply it to table2Data if it's already loaded
        table2Data.forEach(row => {
            row["Date of Billed"] = selectedDate; // Update the "Date of Billed" for each row
        });
        renderTable('excelData2', table2Data); // Re-render table 2 with new "Date of Billed"
    }
});



document.getElementById('upload2').addEventListener('change', function (e) {
    const file = e.target.files[0];
    const reader = new FileReader();

    // Show the loading indicator before starting the file processing
    document.getElementById('loadingIndicator').style.display = 'block';

    reader.onload = function (event) {
        const data = event.target.result;
        const workbook = XLSX.read(data, { type: 'binary' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        table2Data = XLSX.utils.sheet_to_json(sheet); // Store data in table2Data

        // If a date has already been selected, apply it to the rows
        if (selectedDate) {
            table2Data.forEach(row => {
                row["Date of Billed"] = selectedDate;
            });
        }

        // Render table 2 (with or without 'Paid' column)
        renderTable('excelData2', table2Data);

        // After rendering, update 'paid' values where missing
        updatePaidAmounts();

        // Hide the loading indicator once the process is complete
        document.getElementById('loadingIndicator').style.display = 'none';
    };

    reader.readAsBinaryString(file);
});



        document.getElementById('save').addEventListener('click', function () {
            if (table2Data.length === 0) {
                alert("No data available to save.");
                return;
            }

            const worksheet = XLSX.utils.json_to_sheet(table2Data);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Updated Data');
            XLSX.writeFile(workbook, `${selectedDate} Updated_File.xlsx`);
        });


    </script>

</body>

</html>